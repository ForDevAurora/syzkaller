// autogenerated by syzkaller (https://github.com/google/syzkaller)

#define _GNU_SOURCE 

#include <endian.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <unistd.h>

struct ipv6_addr_def {
	uint8_t addr[16];
};

struct ipv6_addr {
	uint64_t a0;
	uint64_t a1;
};

static long syz_ipv6_addr_gen(volatile long a0, volatile long a1, volatile long a2, volatile long a3)
{
	struct ipv6_addr_def* addr = (struct ipv6_addr_def*)a0;
	struct ipv6_addr* ipv6_addr = (struct ipv6_addr*)a1;
	ipv6_addr->a0 = (((long)(addr->addr[0])) << 56) | (((long)(addr->addr[1])) << 48) | (((long)(addr->addr[2])) << 40) | (((long)(addr->addr[3])) << 32) | (((long)(addr->addr[4])) << 24) | (((long)(addr->addr[5])) << 16) | (((long)(addr->addr[6])) << 8) | (((long)(addr->addr[7])));
	ipv6_addr->a1 = (((long)(addr->addr[8])) << 56) | (((long)(addr->addr[9])) << 48) | (((long)(addr->addr[10])) << 40) | (((long)(addr->addr[11])) << 32) | (((long)(addr->addr[12])) << 24) | (((long)(addr->addr[13])) << 16) | (((long)(addr->addr[14])) << 8) | (((long)(addr->addr[15])));
	long* ipv6_addr_part1 = (long*)a2;
	long* ipv6_addr_part2 = (long*)a3;
	*ipv6_addr_part1 = ipv6_addr->a0;
	*ipv6_addr_part2 = ipv6_addr->a1;
	return 0;
}

struct mac_addr {
	uint32_t a0;
	uint16_t a1;
};

struct mac_addr_def {
	uint8_t addr[6];
};

static long syz_mac_addr_gen(volatile long a0, volatile long a1, volatile long a2, volatile long a3)
{
	struct mac_addr_def* addr = (struct mac_addr_def*)a0;
	struct mac_addr* mac_addr = (struct mac_addr*)a1;
	mac_addr->a0 = (addr->addr[0] << 24) | (addr->addr[1] << 16) | (addr->addr[2] << 8) | addr->addr[3];
	mac_addr->a1 = (addr->addr[4] << 8) | addr->addr[5];
	uint32_t* mac_addr_part1 = (uint32_t*)a2;
	uint16_t* mac_addr_part2 = (uint16_t*)a3;
	*mac_addr_part1 = mac_addr->a0;
	*mac_addr_part2 = mac_addr->a1;
	return 0;
}

int main(void)
{
		syscall(__NR_mmap, /*addr=*/0x1ffffffff000ul, /*len=*/0x1000ul, /*prot=*/0ul, /*flags=MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE*/0x32ul, /*fd=*/(intptr_t)-1, /*offset=*/0ul);
	syscall(__NR_mmap, /*addr=*/0x200000000000ul, /*len=*/0x1000000ul, /*prot=PROT_WRITE|PROT_READ|PROT_EXEC*/7ul, /*flags=MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE*/0x32ul, /*fd=*/(intptr_t)-1, /*offset=*/0ul);
	syscall(__NR_mmap, /*addr=*/0x200001000000ul, /*len=*/0x1000ul, /*prot=*/0ul, /*flags=MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE*/0x32ul, /*fd=*/(intptr_t)-1, /*offset=*/0ul);
	const char* reason;
	(void)reason;
				if (write(1, "executing program\n", sizeof("executing program\n") - 1)) {}
memset((void*)0x200000000040, 170, 5);
*(uint8_t*)0x200000000045 = 0xaa;
syz_mac_addr_gen(/*addr=*/0x200000000040, /*mac_addr=*/0x200000000080, /*mac_addr_out1=*/0x2000000000c0, /*mac_addr_out2=*/0x200000000100);
*(uint8_t*)0x200000000400 = 0xfe;
*(uint8_t*)0x200000000401 = 0x80;
memset((void*)0x200000000402, 0, 13);
*(uint8_t*)0x20000000040f = 0xbb;
syz_ipv6_addr_gen(/*addr=*/0x200000000400, /*ipv6_addr=*/0x200000000440, /*ipv6_addr_out1=*/0x200000000480, /*ipv6_addr_out2=*/0x2000000004c0);
*(uint8_t*)0x200000000700 = -1;
*(uint8_t*)0x200000000701 = 2;
memset((void*)0x200000000702, 0, 13);
*(uint8_t*)0x20000000070f = 1;
syz_ipv6_addr_gen(/*addr=*/0x200000000700, /*ipv6_addr=*/0x200000000740, /*ipv6_addr_out1=*/0x200000000780, /*ipv6_addr_out2=*/0x2000000007c0);
	return 0;
}
