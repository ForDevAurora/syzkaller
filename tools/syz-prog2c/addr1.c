// autogenerated by syzkaller (https://github.com/google/syzkaller)

#define _GNU_SOURCE 

#include <endian.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <unistd.h>

#define BITMASK(bf_off,bf_len) (((1ull << (bf_len)) - 1) << (bf_off))
#define STORE_BY_BITMASK(type,htobe,addr,val,bf_off,bf_len) *(type*)(addr) = htobe((htobe(*(type*)(addr)) & ~BITMASK((bf_off), (bf_len))) | (((type)(val) << (bf_off)) & BITMASK((bf_off), (bf_len))))

struct csum_inet {
	uint32_t acc;
};

static void csum_inet_init(struct csum_inet* csum)
{
	csum->acc = 0;
}

static void csum_inet_update(struct csum_inet* csum, const uint8_t* data, size_t length)
{
	if (length == 0)
		return;
	size_t i = 0;
	for (; i < length - 1; i += 2)
		csum->acc += *(uint16_t*)&data[i];
	if (length & 1)
		csum->acc += le16toh((uint16_t)data[length - 1]);
	while (csum->acc > 0xffff)
		csum->acc = (csum->acc & 0xffff) + (csum->acc >> 16);
}

static uint16_t csum_inet_digest(struct csum_inet* csum)
{
	return ~csum->acc;
}

struct tcp_seq_num {
	uint32_t seq;
	uint32_t ack;
};

static long syz_port_gen(volatile long a0, volatile long a1)
{
	struct tcp_seq_num* seq = (struct tcp_seq_num*)a1;
	uint16_t port = (uint16_t)a0;
	uint16_t network_port = htons(port);
	seq->seq = 12345;
	seq->ack = 54321;
	return (long)network_port;
}

struct ipv4_addr_def {
	uint32_t addr;
};

static long syz_ipv4_addr_gen(volatile long a0)
{
	struct ipv4_addr_def* addr = (struct ipv4_addr_def*)a0;
	return (long)addr;
}

uint64_t r[8] = {0x0, 0x0, 0x0, 0x41424344, 0x0, 0x41424344, 0x0, 0x0};

int main(void)
{
		syscall(__NR_mmap, /*addr=*/0x1ffffffff000ul, /*len=*/0x1000ul, /*prot=*/0ul, /*flags=MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE*/0x32ul, /*fd=*/(intptr_t)-1, /*offset=*/0ul);
	syscall(__NR_mmap, /*addr=*/0x200000000000ul, /*len=*/0x1000000ul, /*prot=PROT_WRITE|PROT_READ|PROT_EXEC*/7ul, /*flags=MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE*/0x32ul, /*fd=*/(intptr_t)-1, /*offset=*/0ul);
	syscall(__NR_mmap, /*addr=*/0x200001000000ul, /*len=*/0x1000ul, /*prot=*/0ul, /*flags=MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE*/0x32ul, /*fd=*/(intptr_t)-1, /*offset=*/0ul);
	const char* reason;
	(void)reason;
				intptr_t res = 0;
	if (write(1, "executing program\n", sizeof("executing program\n") - 1)) {}
*(uint32_t*)0x200000000000 = htobe32(0);
	res = -1;
res = syz_ipv4_addr_gen(/*addr=*/0x200000000000);
	if (res != -1)
		r[0] = res;
*(uint32_t*)0x200000000040 = htobe32(0xa010102);
	res = -1;
res = syz_ipv4_addr_gen(/*addr=*/0x200000000040);
	if (res != -1)
		r[1] = res;
syz_port_gen(/*host_port=*/0x4e26, /*seq=*/0x200000000080);
	res = -1;
res = syz_port_gen(/*host_port=*/0x4e26, /*seq=*/0x2000000000c0);
	if (res != -1) {
		r[2] = res;
r[3] = *(uint32_t*)0x2000000000c0;
	}
	res = -1;
res = syz_port_gen(/*host_port=*/0x4e27, /*seq=*/0x200000000100);
	if (res != -1) {
		r[4] = res;
r[5] = *(uint32_t*)0x200000000100;
	}
*(uint32_t*)0x200000000300 = htobe32(0x64010102);
	res = -1;
res = syz_ipv4_addr_gen(/*addr=*/0x200000000300);
	if (res != -1)
		r[6] = res;
*(uint8_t*)0x200000000340 = 0xac;
*(uint8_t*)0x200000000341 = 0x14;
*(uint8_t*)0x200000000342 = 0x14;
*(uint8_t*)0x200000000343 = 0xbb;
//syz_ipv4_addr_gen(/*addr=*/0x200000000340);
*(uint8_t*)0x200000000380 = 0xac;
*(uint8_t*)0x200000000381 = 0x14;
*(uint8_t*)0x200000000382 = 0x14;
*(uint8_t*)0x200000000383 = 0xaa;
	res = -1;
res = syz_ipv4_addr_gen(/*addr=*/0x200000000380);
	if (res != -1)
		r[7] = res;
memset((void*)0x2000000003c0, 0, 6);
memset((void*)0x2000000003c6, 0, 6);
*(uint16_t*)0x2000000003cc = htobe16(0x88a8);
STORE_BY_BITMASK(uint16_t, , 0x2000000003ce, 4, 0, 3);
STORE_BY_BITMASK(uint16_t, , 0x2000000003ce, 1, 3, 1);
STORE_BY_BITMASK(uint16_t, , 0x2000000003ce, 3, 4, 12);
*(uint16_t*)0x2000000003d0 = htobe16(0x8100);
STORE_BY_BITMASK(uint16_t, , 0x2000000003d2, 6, 0, 3);
STORE_BY_BITMASK(uint16_t, , 0x2000000003d2, 0, 3, 1);
STORE_BY_BITMASK(uint16_t, , 0x2000000003d2, 3, 4, 12);
*(uint16_t*)0x2000000003d4 = htobe16(0x800);
STORE_BY_BITMASK(uint8_t, , 0x2000000003d6, 0x2f, 0, 4);
STORE_BY_BITMASK(uint8_t, , 0x2000000003d6, 4, 4, 4);
STORE_BY_BITMASK(uint8_t, , 0x2000000003d7, 0, 0, 2);
STORE_BY_BITMASK(uint8_t, , 0x2000000003d7, 9, 2, 6);
*(uint16_t*)0x2000000003d8 = htobe16(0xdf);
*(uint16_t*)0x2000000003da = htobe16(0x68);
*(uint16_t*)0x2000000003dc = htobe16(0);
*(uint8_t*)0x2000000003de = 7;
*(uint8_t*)0x2000000003df = 6;
*(uint16_t*)0x2000000003e0 = htobe16(0);
*(uint32_t*)0x2000000003e2 = r[0];
*(uint32_t*)0x2000000003e6 = r[1];
*(uint8_t*)0x2000000003ea = 0x89;
*(uint8_t*)0x2000000003eb = 0x17;
*(uint8_t*)0x2000000003ec = 0xd8;
*(uint32_t*)0x2000000003ed = r[6];
*(uint32_t*)0x2000000003f1 = r[1];
*(uint32_t*)0x2000000003f5 = r[7];
*(uint32_t*)0x2000000003f9 = r[0];
*(uint32_t*)0x2000000003fd = r[1];
*(uint8_t*)0x200000000401 = 0x44;
*(uint8_t*)0x200000000402 = 0x3c;
*(uint8_t*)0x200000000403 = 0x88;
STORE_BY_BITMASK(uint8_t, , 0x200000000404, 3, 0, 4);
STORE_BY_BITMASK(uint8_t, , 0x200000000404, 1, 4, 4);
*(uint32_t*)0x200000000405 = r[1];
*(uint32_t*)0x200000000409 = htobe32(0);
*(uint32_t*)0x20000000040d = r[0];
*(uint32_t*)0x200000000411 = htobe32(3);
*(uint32_t*)0x200000000415 = r[1];
*(uint32_t*)0x200000000419 = htobe32(0xffff);
*(uint32_t*)0x20000000041d = r[1];
*(uint32_t*)0x200000000421 = htobe32(0x7ff);
*(uint32_t*)0x200000000425 = r[1];
*(uint32_t*)0x200000000429 = htobe32(8);
*(uint32_t*)0x20000000042d = r[1];
*(uint32_t*)0x200000000431 = htobe32(1);
*(uint32_t*)0x200000000435 = 0;
*(uint32_t*)0x200000000439 = htobe32(6);
*(uint8_t*)0x20000000043d = 0x86;
*(uint8_t*)0x20000000043e = 0x3e;
*(uint32_t*)0x20000000043f = htobe32(0xfffffffd);
*(uint8_t*)0x200000000443 = 2;
*(uint8_t*)0x200000000444 = 3;
memset((void*)0x200000000445, 135, 1);
*(uint8_t*)0x200000000446 = 7;
*(uint8_t*)0x200000000447 = 0xe;
memcpy((void*)0x200000000448, "\xf8\x2d\x1c\x25\x0b\x41\x1b\xb9\xb9\x71\xd2\x81", 12);
*(uint8_t*)0x200000000454 = 0;
*(uint8_t*)0x200000000455 = 0xd;
memcpy((void*)0x200000000456, "\x0e\xd1\x55\x79\x7c\x93\xe3\xb0\x44\x30\x8c", 11);
*(uint8_t*)0x200000000461 = 2;
*(uint8_t*)0x200000000462 = 0x11;
memcpy((void*)0x200000000463, "\x74\x5a\x0b\xbe\xd0\x7f\x7b\x46\xa2\xe8\x0f\xaf\x4f\x65\x0f", 15);
*(uint8_t*)0x200000000472 = 1;
*(uint8_t*)0x200000000473 = 4;
memcpy((void*)0x200000000474, "\xde\x59", 2);
*(uint8_t*)0x200000000476 = 5;
*(uint8_t*)0x200000000477 = 2;
*(uint8_t*)0x200000000478 = 0;
*(uint8_t*)0x200000000479 = 3;
memset((void*)0x20000000047a, 147, 1);
*(uint8_t*)0x20000000047b = 0x44;
*(uint8_t*)0x20000000047c = 0x14;
*(uint8_t*)0x20000000047d = 0x33;
STORE_BY_BITMASK(uint8_t, , 0x20000000047e, 0, 0, 4);
STORE_BY_BITMASK(uint8_t, , 0x20000000047e, 0, 4, 4);
*(uint32_t*)0x20000000047f = htobe32(0xff);
*(uint32_t*)0x200000000483 = htobe32(3);
*(uint32_t*)0x200000000487 = htobe32(0x8a46);
*(uint32_t*)0x20000000048b = htobe32(0);
*(uint16_t*)0x200000000492 = r[4];
*(uint16_t*)0x200000000494 = r[2];
*(uint32_t*)0x200000000496 = r[5];
*(uint32_t*)0x20000000049a = r[3];
STORE_BY_BITMASK(uint8_t, , 0x20000000049e, 1, 0, 1);
STORE_BY_BITMASK(uint8_t, , 0x20000000049e, 0, 1, 3);
STORE_BY_BITMASK(uint8_t, , 0x20000000049e, 5, 4, 4);
*(uint8_t*)0x20000000049f = 0xa6;
*(uint16_t*)0x2000000004a0 = htobe16(0x100);
*(uint16_t*)0x2000000004a2 = htobe16(0);
*(uint16_t*)0x2000000004a4 = htobe16(0);
memcpy((void*)0x2000000004a6, "\x89\x55\x36\x1a\x2e\x50\x7b\x7f\x21\x10\x57\xc8\x62\x3f\xc0", 15);
*(uint32_t*)0x2000000004c0 = 1;
*(uint32_t*)0x2000000004c4 = 3;
*(uint32_t*)0x2000000004c8 = 0xab1;
*(uint32_t*)0x2000000004cc = 0xee1;
*(uint32_t*)0x2000000004d0 = 0x741;
*(uint32_t*)0x2000000004d4 = 0xa23;
	struct csum_inet csum_1;
	csum_inet_init(&csum_1);
csum_inet_update(&csum_1, (const uint8_t*)0x2000000003e2, 4);
csum_inet_update(&csum_1, (const uint8_t*)0x2000000003e6, 4);
	uint16_t csum_1_chunk_2 = 0x600;
	csum_inet_update(&csum_1, (const uint8_t*)&csum_1_chunk_2, 2);
	uint16_t csum_1_chunk_3 = 0x2300;
	csum_inet_update(&csum_1, (const uint8_t*)&csum_1_chunk_3, 2);
csum_inet_update(&csum_1, (const uint8_t*)0x200000000492, 35);
*(uint16_t*)0x2000000004a2 = csum_inet_digest(&csum_1);
	struct csum_inet csum_2;
	csum_inet_init(&csum_2);
csum_inet_update(&csum_2, (const uint8_t*)0x2000000003d6, 188);
*(uint16_t*)0x2000000003e0 = csum_inet_digest(&csum_2);
// syz_emit_ethernet_tcp(/*len=*/0xf5, /*packet=*/0x2000000003c0, /*frags=*/0x2000000004c0);
// Dump the packet in hex format
printf("Packet: ");
for (int i = 0; i < 0xf5; i++) {
    printf("%02x ", ((uint8_t*)0x2000000003c0)[i]);
}
printf("\n");

	return 0;
}
